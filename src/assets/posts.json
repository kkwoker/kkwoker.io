[
  {
    "routeKey": "loremipsum",
    "title": "Lorem Ipsum",
    "date": "2018-01-08T05:01:47.000Z",
    "tags": [
      "mathematics",
      "algorithms"
    ],
    "draft": true,
    "image": {
      "feature": "/images/abstract-10.jpg"
    },
    "html": "<p>A perfect matching S is a matching with the property that each member of M and\neach member of W appears in exactly one pair in S.</p>\n<p>blahblahla</p>\n<h2 id=\"gale-shapely-algorithm\">Gale-Shapely Algorithm</h2>\n<pre><code>Initially all m ∈ M and w ∈ W are free\nWhile there is a man m who is free and hasn&#39;t proposed to every woman\n  Choose such a man m\n  Let w be the highest-ranked woman in m&#39;s preference list to whom m has not yet\n  proposed\n  If w is free then\n    (m, w) become engaged\n  Else w is currently engaged to m&#39;\n    If w prefers m&#39; to m then\n      m remains free\n    Else w prefers m to m&#39;\n      (m, w) become engaged\n      m&#39; becomes free\n    EndIf\n  EndIf\nEndWhile\nReturn the set S of engaged pairs\n</code></pre><h3 id=\"thm-0-the-algorithm-always-stops-\">Thm 0. The algorithm always stops.</h3>\n<p>Finitely number of preferences</p>\n<h3 id=\"thm-1-the-algorithm-arranges-stable-marriages-\">Thm 1. The algorithm arranges stable marriages.</h3>\n<p>Proof: Show that no woman can trade up, the husband is the best she can do.</p>\n<p>Each man a given woman prefers rejected her on the way. QED</p>\n<h3 id=\"thm-2-the-algorithm-is-man-optimal\">Thm 2. The algorithm is man-optimal</h3>\n<h3 id=\"collorary-the-algorithm-is-woman-pessimal\">Collorary: The algorithm is woman-pessimal</h3>\n"
  },
  {
    "routeKey": "first-post",
    "title": "IT'S ALIVE!!!",
    "date": "2018-04-09T00:00:00.000Z",
    "draft": false,
    "html": "<p>My simple website built on React is finally up!</p>\n<p>I haven&#39;t been this proud of my own creation since... well since a very long time.\nWork and school had been keeping me busy, so I never had the time to\nwork on my own projects. This past week however, I decided to take some time off\nand finally tackle those things I&#39;ve been meaning to do. Also, I have exams this week, so\nthe extra time to study wouldn&#39;t hurt!</p>\n"
  },
  {
    "routeKey": "algorithms-cheat-sheet",
    "title": "Algorithms Cheat Sheet",
    "date": "2018-04-11T00:00:00.000Z",
    "tags": [
      "mathematics",
      "algorithms"
    ],
    "draft": false,
    "html": "<h5 id=\"this-list-is-not-extensive-nor-is-it-entirely-accurate-just-the-main-facts-needed-for-basic-analysis\">This list is not extensive nor is it <em>entirely</em> accurate. Just the main facts needed for basic analysis</h5>\n<p><a href=\"https://www.math.uh.edu/~ilya/class/useful_summations.pdf\">Useful Summation Series</a></p>\n<p><img src=\"http://latex.codecogs.com/gif.latex?%5Csum_%7Bk%3D0%7D%5E%7Bn%7Da%5Ek%20%3D%20%5Cfrac%7Ba%5E%7Bn&plus;1%7D%20-%201%7D%7Ba-1%7D\" alt=\"finite sum a k\"></p>\n<h2 id=\"data-structures\">Data Structures</h2>\n<h4 id=\"binary-tree\">Binary Tree</h4>\n<h4 id=\"max-min-heaps-and-priority-queues\">Max/min Heaps and Priority Queues</h4>\n<h4 id=\"linked-lists\">Linked Lists</h4>\n<h2 id=\"growth-of-functions\">Growth of Functions</h2>\n<h4 id=\"asymptotic-notation\">Asymptotic notation</h4>\n<p>ϴ-notation asymptotic tight bound</p>\n<p>O-notation asymptotic upper bound</p>\n<p>Ω-notation asymptotic lower bound</p>\n<p><img src=\"http://latex.codecogs.com/gif.latex?O%28%5Clog%7Bn%7D%29%20%5Cleq%20O%28n%29%20%5Cleq%20O%28n%5Clog%7Bn%7D%29%20%5Cleq%20O%28n%5Ek%29%20%5Cleq%20O%28k%5En%29%20%5Cleq%20O%28n%21%29\" alt=\"O(\\log{n}) \\leq O(n) \\leq  O(n\\log{n}) \\leq  O(n^k) \\leq O(k^n) \\leq  O(n!)\"></p>\n<p><img src=\"http://latex.codecogs.com/gif.latex?%5Cbinom%7Bn%7D%7Bk%7D%20%3D%20O%28n%5Ek%20/%20k%21%29%20%3D%20O%28n%5Ek%29\" alt=\"\\binom{n}{k} = O(n^k / k!) = O(n^k)\"></p>\n<h2 id=\"elementary-graph-algorithms\">Elementary Graph Algorithms</h2>\n<h4 id=\"breadth-first-search\">Breadth First Search</h4>\n<pre><code>BFS(G, s)\n    for each v ∃ V - {s}\n        v.color = WHITE\n        v.d = INFINITY\n        v.pi = NIL\n    s.color = GRAY\n    s.d = 0\n    s.pi = NIL\n    Q = 0\n    ENQUEUE(Q, s)\n    while Q != 0\n        u = DEQUEUE(Q)\n        for each v ∃ Adjacent(u)\n            if v.color == WHITE\n                v.color = GRAY\n                v.d = u.d + 1\n                v.pi = u\n                ENQUEUE(Q, v)\n        u.color = BLACK\nO(|V| + |E|)\n</code></pre><h4 id=\"depth-first-search\">Depth First Search</h4>\n<pre><code>DFS(G)\n    for each u ∃ V\n        u.color = WHITE\n        u.pi = NIL\n    time = 0\n    for each vertex u ∃ V\n        if u.color == WHITE\n            DFS-VISIT(G, u)\nDFS-VISIT(G, u)\n    time = time + 1\n    u.d = time\n    u.color = GRAY\n    for each v ∃ Adjacent(u)\n        if v.color == WHITE\n            v.pi = u\n            DFS-VISIT(G, v)\n    u.color = BLACK\n    time = time + 1\n    u.f = time\nO(|V| + |E|)\n\n</code></pre><h4 id=\"topological-sorting\">Topological Sorting</h4>\n<pre><code>  call DGS(G) to compute finish times v.f for each vertex v\n  as each vertex is finished, insert it onto the front of a linked list\n  return the linked list of vertices\n</code></pre><h2 id=\"divide-and-conquer\">Divide and Conquer</h2>\n<h4 id=\"substitution-method\">Substitution Method</h4>\n<p><img src=\"http://latex.codecogs.com/svg.latex?%5Ctext%7BLet%20%7D%20m%20%3D%20%5Clog%7Bn%7D%20%5C%5C%20%5Ctext%7BLet%20%7D%20S%28m%29%20%3D%20%5Cfrac%7BT%282%5Em%29%7D%7B2%5Em%7D%5C%5C%20%5Cbegin%7Balign*%7D%20T%28n%29%20%26%3D%20%5Csqrt%7Bn%7DT%28%5Csqrt%7Bn%7D%29%20&plus;%20n%20%5C%5C%20T%282%5Em%29%20%26%3D%202%5E%7Bm/2%7DT%282%5E%7Bm/2%7D%29%20&plus;%202%5Em%20%5C%5C%20%5Cfrac%7BT%282%5Em%29%7D%7B2%5Em%7D%20%26%3D%20%5Cfrac%7BT%282%5E%7Bm/2%7D%29%7D%7B2%5E%7Bm/2%7D%7D%20&plus;%201%5C%5C%20S%28m%29%20%26%3D%20S%28%5Cfrac%7Bm%7D%7B2%7D%29%20&plus;%201%5C%5C%20S%28m%29%20%26%3D%20%5CTheta%20%28%5Clog%7Bm%7D%29%20%5C%5C%20%5Cfrac%7BT%282%5Em%29%7D%7B2%5Em%7D%20%26%3D%20%5CTheta%20%28%5Clog%7Bm%7D%29%20%5C%5C%20T%28n%29%20%26%3D%20n%5CTheta%20%28%5Clog%7B%5Clog%7Bn%7D%7D%29%20%5C%5C%20T%28n%29%20%26%3D%20%5CTheta%20%28n%5Clog%7B%5Clog%7Bn%7D%7D%29%20%5C%5C%20%5Cend%7Balign*%7D\" alt=\"\\text{Let } m = \\log{n} \\\\\n\\text{Let } S(m) = \\frac{T(2^m)}{2^m}\\\\\n\\begin{align*}\nT(n)  &amp;= \\sqrt{n}T(\\sqrt{n}) + n \\\\\nT(2^m) &amp;= 2^{m/2}T(2^{m/2}) + 2^m \\\\\n\\frac{T(2^m)}{2^m} &amp;= \\frac{T(2^{m/2})}{2^{m/2}} + 1\\\\\nS(m) &amp;= S(\\frac{m}{2}) + 1\\\\\nS(m) &amp;= \\Theta (\\log{m}) \\\\\n\\frac{T(2^m)}{2^m} &amp;= \\Theta (\\log{m}) \\\\\nT(n) &amp;= n\\Theta (\\log{\\log{n}}) \\\\\nT(n) &amp;= \\Theta (n\\log{\\log{n}}) \\\\\n\\end{align*}\"></p>\n<h4 id=\"recursion-tree-method\">Recursion-Tree Method</h4>\n<h4 id=\"master-theorem\">Master Theorem</h4>\n<p><img src=\"http://latex.codecogs.com/gif.latex?T%28n%29%20%3D%20aT%28n/b%29%20&plus;%20f%28n%29\" alt=\"master theorem\"></p>\n<ol>\n<li><p>If <img src=\"http://latex.codecogs.com/gif.latex?f%28n%29%20%3D%20O%28n%5E%7Blog_b%7Ba-%5Cepsilon%7D%7D%29\" alt=\"\"> then <img src=\"http://latex.codecogs.com/gif.latex?T%28n%29%20%3D%20%5CTheta%28n%5E%7Blog_b%7Ba%7D%7D%29\" alt=\"\"></p>\n</li>\n<li><p>If <img src=\"http://latex.codecogs.com/gif.latex?f%28n%29%20%3D%20%5CTheta%28n%5E%7Blog_b%7Ba%7D%7D%29\" alt=\"\"> then <img src=\"http://latex.codecogs.com/gif.latex?T%28n%29%20%3D%20%5CTheta%28n%5E%7Blog_b%7Ba%7D%7D%5Clg%20%7Bn%7D%29\" alt=\"\"></p>\n</li>\n<li><p>If <img src=\"http://latex.codecogs.com/gif.latex?f%28n%29%20%3D%20%5COmega%20%28n%5E%7Blog_b%7Ba&plus;%5Cepsilon%20%7D%7D%29\" alt=\"\"> then <img src=\"http://latex.codecogs.com/gif.latex?T%28n%29%20%3D%20%5CTheta%28f%28n%29%29\" alt=\"\"></p>\n</li>\n</ol>\n<h4 id=\"muster-theorem\">Muster Theorem</h4>\n<p><img src=\"http://latex.codecogs.com/gif.latex?T%28n%29%20%3D%20aT%28n%20-%20b%29%20&plus;%20f%28n%29\" alt=\"muster theorem\"></p>\n<ol>\n<li>If <img src=\"http://latex.codecogs.com/gif.latex?a%3C1\" alt=\"\"> then <img src=\"http://latex.codecogs.com/gif.latex?T%28n%29%20%3D%20O%28n%5Ed%29\" alt=\"\"></li>\n<li>If <img src=\"http://latex.codecogs.com/gif.latex?a%3D1\" alt=\"\"> then <img src=\"http://latex.codecogs.com/gif.latex?T%28n%29%20%3D%20O%28n%5E%7Bd%20&plus;%201%7D%29\" alt=\"\"></li>\n<li>If <img src=\"http://latex.codecogs.com/gif.latex?a%3E1\" alt=\"\"> then <img src=\"http://latex.codecogs.com/gif.latex?T%28n%29%20%3D%20O%28n%5E%7Bd%7Da%5E%7Bn/b%7D%29\" alt=\"\"></li>\n</ol>\n<h2 id=\"greedy-algorithms\">Greedy Algorithms</h2>\n<h4 id=\"minimum-spanning-trees\">Minimum Spanning trees</h4>\n<pre><code>GENERIC-MST(G, w)\n    A = 0\n    while A does not form a spanning tree\n        find an edge (u, v) that is safe for A\n        A = A U {(u, v)}\n    return A\n</code></pre><pre><code>MST-KRUSKAL(G, w)\n    A = 0\n    for each v in V\n        MAKE-SET(v)\n    sort the edges of E into increasing order by weight w\n    for each edge (u, v) in E, taken in increasing order by weight\n        if FIND-SET(u) != FIND-SET(v)\n            A = A U {(u, v)}\n            UNION(u, v)\n    return A\n</code></pre><pre><code>MST-PRIM(G, w, r)\n    for each u in V\n        u.key = INFINITY\n        u.pi = NIL\n    r.key = 0\n    Q = V\n    while Q != 0\n        u = EXTRACT-MIN(Q)\n        for each v in Adjacent(u)\n            if v is in Q and w(u, v) &lt; v.key\n                v.pi = u\n                v.key = w(u, v)\n</code></pre><h4 id=\"activity-scheduling\">Activity Scheduling</h4>\n<pre><code>GREEDY-ACTIVITY-SELECTOR(s, f)\n    n = s.length\n    A = {a_1}\n    k = 1\n    for m = 2..n\n        if s[m] &gt;= f[k]\n            A = A U {a_m}\n            k = m\n    return A\n\n</code></pre><h4 id=\"cut-and-paste-argument\">Cut and Paste argument</h4>\n<p>eg. Consider any nonempty subproblem S_k, and let a_m be an activity in S_k with\nthe earliest finish time. Then a_m is included in some maximum-size subset of mutually compatible activities of S_k</p>\n<p>PF: Let A_k be a maximum-size subset of mutually compatible activities in S_k and let a_j be the activity in A_k with the earliest finish time. If a_j = a_m, we are done since we have shown that a_m is in some maximum-size subset of mutually compatible activities of S_k. If a_j != a_m let the set A&#39;_k = A_k - {a_j} U {a_m} be A_k be substituting a_m for a_j. The activities in A&#39;_k are disjoint, which follows because the activities in A_k are disjoint, a_k is the first activity in A_k to finish, and f_m &lt;= f_j. Since |A&#39;_k| = |A_k|, we conclude that A&#39;_k is a maximum size subset of mutually compatible activies of S_k and it includes a_m.</p>\n<h2 id=\"single-source-shortest-paths\">Single Source Shortest Paths</h2>\n<pre><code>INITIALIZE-SINGLE-SOURCE(G, s)\n    for each v in V\n        v.d = INFINITY\n        v.pi = NIL\n    s.d = 0\n</code></pre><pre><code>RELAX(u, v, w)\n    if v.d &gt; u.d + w(u, v)\n        v.d = u.d + w(u, v)\n        v.pi = u\n\n</code></pre><h4 id=\"dijkstra-s\">Dijkstra&#39;s</h4>\n<pre><code>G is a directed or undirected graph (V, E) with no negative cycles reachable from s\nDIJKSTRA(G, w, s)\n    INITIALIZE-SINGLE-SOURCE(G, s)\n    S = 0\n    Q = V\n    while Q != 0\n        u = EXTRACT-MIN(Q)\n        S = S U {u}\n        for each v in Adjacent(u)\n            RELAX(u, v, w)\n</code></pre><h4 id=\"bellman-ford\">Bellman-Ford</h4>\n<pre><code>G is a directed graph\nBELLMAN-FORD(G, w, s)\n    INITIALIZE-SINGLE-SOURCE(G, s)\n        for i = 1 to |V| - 1\n            for each edge (u, v) in E\n                RELAX(u, v, w)\n        for each edge (u, v) in E\n            if v.d &gt; u.d + w(u, v)\n                return FALSE &quot;There exists a negative weight cycle reachable by s&quot;\n        return TRUE &quot;There is no negative weight cycles reachable by s&quot;\n\n</code></pre><h2 id=\"dynamic-programming\">Dynamic Programming</h2>\n<h4 id=\"elements-of-dynamic-programming\">Elements of dynamic programming</h4>\n<h4 id=\"longest-common-subsequence\">Longest common subsequence</h4>\n<h2 id=\"maximum-flow\">Maximum Flow</h2>\n<h4 id=\"max-flow-min-cut-theorem\">Max-Flow Min-Cut Theorem</h4>\n<p>If f is a flow in a flow network G = (V, E) with source s and sink t, then the following are euivalent:</p>\n<ol>\n<li>f is a maximum flow in G.</li>\n<li>The residual network Gf contains no augmenting paths.</li>\n<li>|f| = c(S, T) for some cut (S, T) of G.</li>\n</ol>\n<h4 id=\"ford-fulkerson-method\">Ford-Fulkerson method</h4>\n<pre><code>(u, v).f is the flow along edge (u, v)\nFORD-FULKERSON(G, s, t)\n    for each edge (u, v) in E\n        (u, v).f = 0\n    while there exists a path p from s to t in the residual network Gf\n        cf(p) = min{ cf(u, v): (u, v) is in p }  // Take the bottleneck edge in p\n        for each edge (u, v) in p\n            if (u, v) in E\n                (u, v).f = (u, v).f + cf(p)\n            else\n                (v, u).f = (v, u).f - cf(p)\n\n</code></pre><p>O(|E|C) where C is the maximum flow, since the flow value increases by at least 1 unit each iteration</p>\n<ul>\n<li>Capacity Scaling ~&gt; O(E^2logC) (Looks for the edges with the highest flows first)</li>\n<li>Edmonds-Karp ~&gt; O(VE^2) (uses BFS to find the augmenting path)</li>\n</ul>\n<h4 id=\"maximum-bipartite-matching\">Maximum Bipartite matching</h4>\n<h2 id=\"np-completeness\">NP-Completeness</h2>\n<h4 id=\"sat\">SAT</h4>\n<h4 id=\"independent-set\">Independent Set</h4>\n<h4 id=\"3-colour\">3-colour</h4>\n<h4 id=\"proof-techniques\">Proof techniques</h4>\n<h2 id=\"approximation-algorithms\">Approximation Algorithms</h2>\n<h4 id=\"vertex-cover\">Vertex Cover</h4>\n<pre><code>C = 0\nE&#39; = G.E\nwhile E&#39; != 0\n    let (u, v) be an arbitrary edge of E&#39;\n    C = C ∪ {u, v}\n    remove from E&#39; every edge incident on either u or v\nreturn C\n</code></pre><p>vertex cover whose size is guaranteed to be no more than twice the size of an optimal vertex cover</p>\n<p>Since once an edge is chosen, all other edges incident on its endpoints are deleted from E&#39;, no two edges in C are covered by the same vertex from C_opt</p>\n<h2 id=\"randomized-algorithms\">Randomized Algorithms</h2>\n"
  },
  {
    "html": ""
  }
]